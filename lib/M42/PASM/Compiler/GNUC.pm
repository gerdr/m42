use v6;
use M42::PASM::Compiler;
class M42::PASM::Compiler::GNUC does M42::PASM::Compiler;

my $PREFIX = '// generated by M42::PASM::Compiler::GNUC

#include <m42/base.h>
';

my %TYPEMAP =
	'ptr' => {
		ctype => 'void*',
		vtype => 'p',
	},
	'i64' =>  {
		ctype => 'uint64_t',
		vtype => 'u',
	},
	'f64' =>  {
		ctype => 'double',
		vtype => 'f',
	},
	'val' =>  {
		ctype => 'm42_val',
		vtype => '-',
	}
;

multi compile-constant($ (:$key where 'number', :$value)) {
	$value
}

multi compile-constant($ (:$key, *%)) {
	die "unsupported constant type '$key'"
}

multi compile-base($ (:$sigil where '%', :$name, *%)) {
	"r_$name"
}

multi compile-base($ (:$sigil, *%)) {
	die "unsupported argument sigil '$sigil'"
}

multi compile-arg-to-val($arg (:$key where 'dv',
	:$value (:$sigil where '%', :$name,
		:$type where %TYPEMAP{$type}<vtype> eq any(<i u p f>), *%))) {
	my $vtype = %TYPEMAP{$type}<vtype>;
	"(m42_val)\{ .$vtype = { compile-arg $arg } \}"
}

multi compile-arg($ (:$key where 'iv', :value($_))) {
	"(({ %TYPEMAP{.<type>}<ctype> }*){ compile-base .<base> })[{
		.<index> ?? compile-constant(.<index>) !! 0
	}]"
}

multi compile-arg($arg (:$key where 'dv', :value($_))) {
	compile-base $_
}

multi compile-op($op (:$name where 'jmp', *%)) {
	"goto *{ compile-arg $op<args>[0] };";
}

multi compile-op($op (:$name where 'ret', *%)) {
	"return { compile-arg-to-val $op<args>[0] };"
}

multi compile-op($op (:$name where 'lea', *%)) {
	"{ compile-arg $op<args>[0] } = \&{ compile-arg $op<args>[1] };";
}

multi compile-op($op (:$name where 'mov', *%)) {
	"{ compile-arg $op<args>[0] } = { compile-arg $op<args>[1] };";
}

multi compile-op($ (:$name where 'add', :@args)) {
	sprintf '%s = %s + %s;', @args.map(&compile-arg)
}

multi compile-op($ (:$name where 'fadd', :@args)) {
	sprintf '%s = %s + %s;', @args.map(&compile-arg)
}

multi compile-op($op (:$name, *%)) {
	die "unsupported op '$op<name>'"
}

multi compile-reg($reg (:$type where %TYPEMAP, :name($rname),
	:$init! (:$sigil where '$', :name($aname), *%), *%)) {
	"register { %TYPEMAP{$type}<ctype> } r_$rname = a_$aname;";
}

multi compile-reg($reg (:$type where %TYPEMAP, :$name, *%)) {
	"register { %TYPEMAP{$type}<ctype> } r_$name;";
}

multi compile-reg($reg (:$type, *%)) {
	die "unsupported register type '$type'"
}

multi compile-code($ (:key($type) where 'op', :value($op))) {
	compile-op $op
}

multi compile-code($ (:key($type) where 'label', :value($label))) {
	my $name = $label<name>;
	"\n$name:\n\t__asm__ __volatile__ (\"$name:\");"
}

multi compile-code($ (:key($type), :$value)) {
	die "unsupported code type $type"
}

sub compile-labels(*@labels) {
	'static const void *const labels_[] = { '
		~ @labels.map('&&' ~ *.<name>).join(', ')
		~ ' };',
	'__asm__ __volatile__ ("'
		~ @labels.map('.global ' ~ *.<name>).join('\n')
		~ '");',
	'(void)labels_;'
}

method dump {
	print $PREFIX;

	for %.chunks.values {
		my @statements := gather {
			if .<labels> {
				take compile-labels .<labels>.list
			}

			take '';

			for .<regs>.values {
				take compile-reg $_
			}

			take '';

			for .<code>.list {
				take compile-code $_
			}
		}

		my @args = .<args>.kv.map(-> $index, $type {
			"%TYPEMAP{$type}<ctype> a_$index"
		});

		print "
m42_val { .<name> }({ @args.join(', ') || 'void' })
\{
	{ @statements.join("\n\t") }
}
";
	}
}
